// Copyright 1996 September 3, United States Government as Represented   
// by the Director, National Security Agency. All rights reserved.       
//                                                                       
// Disclaimer 1: NCSA expressly disclaims any and all warranties, expressed
// or implied, concerning the enclosed software.  The intent in sharing  
// this software is to promote the productive interchange of ideas       
// throughout the research community. All software is furnished on an    
// "as is" basis. No further updates to this software should be          
// expected. Although this may occur, no commitment exists. The authors  
// certainly invite your comments as well as the reporting of any bugs.  
// NCSA cannot commit that any or all bugs will be fixed.                
//                                                                       
// Disclaimer 2: CCS expressly disclaims any and all warranties, expressed 
// or implied, concerning the enclosed software. This software was       
// developed at CCS for use in internal research. The intent in sharing  
// this software is to promote the productive interchange of ideas       
// throughout the research community. All software is furnished on an    
// "as is" basis. No further updates to this software should be          
// expected. Although this may occur, no commitment exists. The authors  
// certainly invite your comments as well as the reporting of any bugs.  
// CCS cannot commit that any or all bugs will be fixed.                 
//---------------------------------------------------------------------------//
//!
//! \file    LFG.hpp
//! \author  Steven A. Cuccaro and Daniel V. Pryor, Askov Srinivasan 
//!          (IDA/Center for Computing Sciences (CCS), cuccaro@super.org, 
//!           pryor@super.org, ?)
//! \brief   Parallel modified additive lagged fibonacci generator definition
//! \details Modified by J. Ren (Florida State University, ren@csit.fsu.edu ).
//!          This version has been modified to use two integer-based additive
//!          lagged-Fibonacci generators to produce integer, float and double
//!          values. The lagged-Fibonacci generators each have 31 bits of 
//!          precision (after the bit fixed by the canonical form of the  
//!          generator is removed), 31-bit values are generated by XORing     
//!          the values after one has been shifted left one bit. The floating 
//!          point value is formed by dividing the integer by 1.e+32 (the     
//!          lsb's will be dropped from the mantissa to make room for the     
//!          exponent), and two of these integer values in sequence are used  
//!          to get the necessary precision for the double value. This method 
//!          has the advantage that the generators pass fairly strict 
//!          randomness tests, including the Birthday Spacings test that 
//!          additive lagged-Fibonacci generators are well known to fail. The 
//!          disadvantage is the additional time needed to do the division 
//!          explicitly, which was avoided in previous versions. (As the 
//!          division is by powers of 2, the user might well consider making 
//!          machine-specific versions of this code to insert the bits into 
//!          the appropriate places and avoid the problem entirely.) 
//! \note    This file has been rewritten by Alex Robinson (University of
//!          Wisconsin-Madison, aprobinson@wisc.edu). Only minor interface
//!          changes have been made. All of the underlying algorithms are still
//!          the same.
//!
//---------------------------------------------------------------------------//

// Std Lib Includes
#include <vector>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include <assert.h>

// Boost Includes
#include <boost/scoped_ptr.hpp>

// SPRNG Includes
#include "LFG.hpp"
#include "Store.hpp"

#define GENTYPE "Additive Lagged Fibonacci Generator"
#define INT_MOD_MASK 0xffffffff
#define FLT_MULT (0.25/(unsigned)(1<<30))
// INT_MASK is used to mask out the part of the generator which is not in the 
// canonical form; it should be 2^{32-1}-1 
#define INT_MASK ((unsigned)INT_MOD_MASK>>1)
// MAX_BIT_INT is the largest bit position allowed in the index of the node - 
// it equals 32 - 2
#define MAX_BIT_INT (32-2)
// INTX2_MASK is used in calculation of the node numbers
#define INTX2_MASK ((1<<MAX_BIT_INT)-1)
// RUNUP keeps certain generators from looking too similar in the first few 
// words output                                    
#define RUNUP (2*32)
// GS0 gives a more "random" distribution of generators when the user uses 
// small integers as seeds
#define GS0 0x372f05ac

namespace sprng{

// Default constructor
LFG::LFG() 
  : d_rng_type( LFG ),
    d_gentype( GENTYPE ),
    d_si(),
    d_r0(),
    d_r1(),
    d_stream_number( 0 ),
    d_hptr( 0 ),
    d_seed( 0 ),
    d_init_seed( 0 ),
    d_lval( 0 ),
    d_kval( 0 ),
    d_param( 0 )
{ /* ... */ }

// Copy constructor
LFG::LFG( const LFG &c )
  : d_rng_type( c.d_rng_type ),
    d_gentype( c.d_gentype ),
    d_si( c.d_si ),
    d_r0( c.d_r0 ),
    d_r1( c.d_r1 ),
    d_stream_number( c.d_stream_number ),
    d_hptr( c.d_hptr ),
    d_seed( c.d_seed ),
    d_init_seed( c.d_init_seed ),
    d_lval( c.d_lval ),
    d_kval( c.d_kval ),
    d_param( c.d_param )
{ /* ... */ }

// Assignment operator
LFG& operator=( const LFG &c )
{
  if( this != &c )
  {
    this->free_rng();

    d_rng_type = c.d_rng_type;
    d_gentype = c.d_gentype;
    d_si = c.d_si;
    d_r0 = c.d_r0;
    d_stream_number = c.d_stream_number;
    d_hptr = c.d_hptr;
    d_seed = c.d_seed;
    d_init_seed = c.d_init_seed;
    d_lval = c.d_lval;
    d_kval = c.d_kval;
    d_param = c.d_param;
  }

  return *this;
}

// Destructor
LFG::~LFG()
{
  free_rng();
}

// Initialize the generator
/*! \details Give back one generator (node gn) with updated spawning info. This
 * function should be called tg times, with a different value of gn in [0,tn)
 * each call.
 */
int LFG::init_rng( int gn, int tg, int s, int m )
{
  int doexit=0, i, k, length;
  LFG **p = NULL;
  std::vector<unsigned> nstart, si_local;

  // Check if tg is valid
  if (tg <= 0) 
  {
    tg = 1;
    errprint("WARNING","init_rng","Total_gen <= 0. Default value of 1 used for total_gen");
  }

  // Check if gn is valid
  if (gn >= MAX_STREAMS) 
    fprintf(stderr,"WARNING - init_rng: gennum: %d > maximum number of independent streams: %d\n\tIndependence of streams cannot be guranteed.\n",
	    gn, MAX_STREAMS); 

  if (gn < 0 || gn >= tg) 
  {
    errprint("ERROR","init_rng","gennum out of range. "); 
    return 0;
  }

  // Only 31 LSB of seed considered
  s &= 0x7fffffff;		
  
  if (m < 0 || m >= 11) 
  {
    errprint("WARNING","init_rng","Parameter not valid. Using Default param");
    m = 0;
  }
  
  length = LFG::valid[m].L; 
  k = LFG::valid[m].K;

  // Check whether generators have previously been defined. Guard against
  // access while defining generator parameters for the first time.
  if ( !LFG::global_lval ) 
  {
    LFG::global_lval = length; /* determine parameters   */
    LFG::global_kval = k;
    LFG::global_seed = s^GS0;
  }
  else 
  {
    if( LFG::global_lval != length ) 
      doexit++;
    
    if( s != (LFG::global_seed^GS0) ) 
      doexit += 2;

    if( doexit ) 
    {
      if( doexit&1 ) 
	errprint("WARNING","init_rng","changing global L value! Independence of streams is not guaranteed");
      if( doexit&2 ) 
	errprint("WARNING","init_rng","changing global seed value! Independence of streams is not guaranteed");
    }
  }
  
  // Define the starting vector for the initial node 
  nstart.resize( length-1 );
  nstart[0] = gn;

  for( i=1; i<length-1; i++ ) 
    nstart[i] = 0;

  // Create a generator
  p = LFG::initialize( 0, 1, m, s^GS0, nstart, s );  

  if (p == NULL) 
    return 0;
  
  p[0]->d_stream_number = gn;

  // Update si array to allow for future spawning of generators
  si_local = p[0]->d_si;

  while( si_local[0] < tg && !si_local[1] ) 
    LFG::si_double(si_local,si_local,length);

  // Increment the number of open streams
  LFG::num_generators++;
      
  d_rng_type = LFG;
  d_gentype = p[0]->d_gentype;
  d_si = p[0]->si;
  d_r0 = p[0]->d_r0;
  d_r1 = p[0]->d_r1;
  d_stream_number = p[0]->d_stream_number;
  d_hptr = p[0]->d_hptr;
  d_seed = p[0]->d_seed;
  d_init_seed = p[0]->d_init_seed;
  d_lval = p[0]->d_lval;
  d_kval = p[0]->d_kval;
  d_param = p[0]->d_param;

  delete [] p;

  return 1;
}
  
// Return a random int
int LFG::get_rn_int()
{
  unsigned new_val;
  int hptr_local,lptr;
  int local_lval, local_kval;
  
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;
  
  if( lptr >= local_lval ) 
    lptr -= local_lval;
  
  // INT_MOD_MASK causes arithmatic to be modular when integer size is
  // different from the generator modulus
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  new_val = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);
  
  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1; // skip an element in the sequence
    
  if( --lptr < 0 ) 
    lptr = local_lval - 1;
    
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  d_hptr = (--hptr_local < 0) ? local_lval-1 : hptr_local;
  
  return (new_val>>1);
}

// Return a random float in interval [0,1)
float LFG::get_rn_flt()
{
  // Use unsigned long instead of unsigned int due to bug in SGI compiler
  unsigned long new_val; 
  int hptr_local, lptr;
  int local_lval, local_kv;
	
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;
  
  if( lptr >= local_lval ) 
    lptr -= local_lval;

  // INT_MOD_MASK causes arithmetic to be modular when integer size is 
  // different from generator modulus 
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  new_val = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);

  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1; // skip an element in the sequence
  
  if( --lptr < 0 ) 
    lptr = local_lval - 1;

  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  
  d_hptr = (--hptr_local<0) ? local_lval-1 : hptr_local;

  return new_val*FLT_MULT;
}

// Return a random double in interval [0,1)
double LFG::get_rn_dbl()
{
  // Use unsigned long instead of unsigned int due to bug in SGI compiler
  unsigned long temp1,temp2; 
  int hptr_local,lptr;
  double new_val;
  int local_lval, local_kval;
	
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;

  if( lptr >= local_lval ) 
    lptr -= local_lval;

  // INT_MOD_MASK causes arithmetic to be modular when integer size is 
  // different from generator modulus
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  temp1 = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);

  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1;
  
  if( --lptr < 0 ) 
    lptr = local_lval - 1;
  
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  temp2 = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);
  d_hptr = (--hptr_local < 0) ? local_lval-1 : hptr_local;

  new_val = ((unsigned int) temp2*(double)FLT_MULT + 
	     (unsigned int) temp1)*FLT_MULT;

  return new_val;
}

// Spawn new generators
int LFG::spawn_rng( int nspawned, Sprng ***newgens )
{
  LFG **q = NULL;
  int i;
  std::vector<unsigned> p;
  
  // Check if nspawned is valid
  if( nspawned <= 0 ) 
  {
    nspawned = 1;
    errprint("WARNING","spawn_rng","Nspawned <= 0. Default value of 1 used for nspawned");
  }
  
  p = d_si;
  q = LFG::initialize(d_rng_type,nspawned,d_param,d_seed,p,d_init_seed);
  
  if( q == NULL ) 
  {
    *newgens = NULL;
    return 0;
  }
  
  LFG::si_double(p,p,d_lval);

  // Increment the number of open streams
  LFG::num_generators += nspawned;
      
  *newgens = (Sprng **) q;

  return nspawned;
}

// Return the generator seed
int LFG::get_seed_rng()
{
  return (GS0^LFG::global_seed)
}

// Free the memory allocated to this generator
int LFG::free_rng()
{
  LFG::num_generators--;
  
  return LFG::num_generators;
}

// Pack this generator into a character buffer
int LFG::pack_rng( std::string &buffer )
{
  // Clear the buffer
  buffer.clear();

  // All member data will be stored in a sub buffer and appended to main buffer
  std::string partial_buffer;

  // Store the generator type
  store_value( generatorTypeToInt( d_rng_type ), partial_buffer );
  buffer += partial_buffer;

  // Store the L value
  store_value( d_lval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the K value
  store_value( d_kval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the seed
  store_value( d_seed, partial_buffer );
  buffer += partial_buffer;
  
  // Store the initial seed
  store_value( d_init_seed, partial_buffer );
  buffer += partial_buffer;
  
  // Store the stream number
  store_value( d_stream_number, partial_buffer );
  buffer += partial_buffer;
  
  // Store the next branch seeds
  store_array( d_si, partial_buffer );
  buffer += partial_buffer;

  // Store the even generator
  store_array( d_r0, partial_buffer );
  buffer += partial_buffer;
  
  // Store the odd generator
  store_array( d_r1, partial_buffer );
  buffer += partial_buffer;
  
  // Store the integer point into fill
  store_value( d_hptr, partial_buffer );
  buffer += partial_buffer;
    
  return buffer.size();
}

// Print this generators info
int LFG::print_rng()
{
  std::cout << d_gentype << std::endl << std::endl
	    << "\tseed = " << d_init_seed 
	    << ", stream_number = " << d_stream_number
	    << "\tparameter = " << d_param
	    << std::endl << std::endl;

  return 1;  
}

// Unpack this generator from a character buffer
int unpack_rng( std::string &packed )
{
  int doexit=0, i, found, length, k;
  int local_seed, local_param;
  std::size_t nbytes, offset = 0;
  int generator_type;
  int local_lval, local_kval;
  bool valid_values = false;

  // Load the generator type
  nbytes = sizeof( generator_type );
  load_value( packed.substr( offset, nbytes ), generator_type );
  d_rng_type = intToGeneratorType( generator_type );
  offset += nbytes;

  // Load the generator description (not packed because always the same)
  d_gentype = GENTYPE;
  
  // Load the L value
  nbytes = sizeof( d_lval );
  load_value( packed.substr( offset, nbytes ), local_lval );
  offset += nbytes;

  // Load the K value
  nbytes = sizeof( d_kval );
  load_value( packed.substr( offset, nbytes ), local_kval );
  offset += nbytes;
  
  // Check that the L and K value found are valid
  for( i = 0; i < 11; ++i )
  {
    if( local_lval == LFG::valid[i].L && local_kval == LFG::valid[i].K )
    {
      valid_values = true;
      break;
    }
  }

  if( !valid_values )
  {
    fprintf(stderr,"ERROR: Unpacked L and K values are not acceptable.\n");
    return 0;
  }

  local_param = i;
  length = valid[local_param].L;
  k = valid[local_param].K;

  // Set the L value K value and the parameter
  d_lval = length;
  d_kval = k;
  d_param = local_param;

  // Load the seed
  nbytes = sizeof( d_seed );
  load_value( packed.substr( offset, nbytes), local_seed );
  offset += nbytes;
    
  // Check if this is the first stream and if the seed is valid
  if( !LFG::global_lval ) 
  {
    LFG::global_lval = length;
    LFG::global_kval = k;
    LFG::global_seed = local_seed;
  }
  else 
  {
    if( local_seed != LFG::global_seed )
    {
      errprint("WARNING","unpack_rng","different global seed value!");
      fprintf(stderr,"\t Independence of streams is not guaranteed\n");
    }
  }

  // Set the seed
  d_seed = local_seed;

  // Load the initial seed
  nbytes = sizeof( d_init_seed );
  load_value( packed.substr( offset, nbytes ), d_init_seed );
  offset += nbytes;

  // Load the stream number
  nbytes = sizeof( d_stream_number );
  load_value( packed.substr( offset, nbytes), d_stream_number );
  
  // Resize the stored arrays
  d_si.resize( length - 1 );
  d_r0.resize( length );
  d_r1.resize( length );

  // Load the next branch seeds
  nbytes = sizeof( unsigned )*d_si.size();
  load_array( packed.substr( offset, nbytes ), d_si.size(), d_si );
  offset += nbytes;
  
  // Load the even generator
  nbytes = sizeof( unsigned )*d_r0.size();
  load_array( packed.substr( offset, nbytes ), d_r0.size(), d_r0 );
  offset += nbytes;

  // Load the odd generator
  nbytes = sizeof( unsigned )*d_r1.size();
  load_array( packed.substr( offset, nbytes ), d_r1.size(), d_r1 );
  offset += nbytes;
  
  // Load the integer pointer into fill
  nbytes = sizeof( d_hptr );
  load_value( packed.substr( offset, nbytes ), d_hptr );
  offset += nbytes;
  
  LFG::num_generators++;

  return 1;
}

// Get the bit count
int LFG::bitcnt( int x )
{
  unsigned i=0,y;

  for (y=(unsigned)x; y; y &= (y-1) ) 
    i++;

  return i;
}

// Advance the registers
/*! details The register steps according to the primitive polynomial
 * (64,4,3,1,0). Each call steps the register 64 times. Two words are used
 * to represent the register and to allow for an integer size of 32 bits.
 */
int advance_reg( std::vector<int> &reg_fill )
{
  assert( reg_fill.size() == 2 );
  
  const int mask = 0x1b;
  int adv_64[4][2];

  int i,new_fill[2];
  unsigned temp;

  adv_64[0][0] = 0xb0000000;
  adv_64[0][1] = 0x1b;
  adv_64[1][0] = 0x60000000;
  adv_64[1][1] = 0x2d;
  adv_64[2][0] = 0xc0000000;
  adv_64[2][1] = 0x5a;
  adv_64[3][0] = 0x80000000;
  adv_64[3][1] = 0xaf;
  new_fill[1] = new_fill[0] = 0;
  temp = mask<<27;

  for (i=27;i>=0;i--) 
  {
    new_fill[0] = (new_fill[0]<<1) | (1&bitcnt(reg_fill[0]&temp));
    new_fill[1] = (new_fill[1]<<1) | (1&bitcnt(reg_fill[1]&temp));
    temp >>= 1;
  }

  for (i=28;i<32;i++) 
  {
    temp = bitcnt(reg_fill[0]&(mask<<i));
    temp ^= bitcnt(reg_fill[1]&(mask>>(32-i)));
    new_fill[0] |= (1&temp)<<i;
    temp = bitcnt(reg_fill[0]&adv_64[i-28][0]);
    temp ^= bitcnt(reg_fill[1]&adv_64[i-28][1]);
    new_fill[1] |= (1&temp)<<i;
  }

  reg_fill[0] = new_fill[0];
  reg_fill[1] = new_fill[1];
}

// Get the register fill
/*! \details initialize the shift register with the node number XORed with the
 * global seed. Fill the shift register with two copies of this number except
 * when its equal to zero.
 */
int get_fill( std::vector<unsigned> &n, 
	      std::vector<unsigned> &r, 
	      int param_local, 
	      unsigned seed_local )
{
  assert( n.size() == LFG::valid[param_local].L-1 );
  assert( r.size() == LFG::valid[param_local].L );
  
  int i,j,k, length;
  std::vector<int> temp( 2 );

  length = LFG::valid[param_local].L;
  
  temp[1] = temp[0] = n[0]^seed_local;

  if ( !temp[0] )
    temp[0] = GS0;

  // Advance the shift register some
  advance_reg( temp );
  advance_reg( temp );

  // The first word in the generator is defined by the 31 LSBs of the node 
  // number 
  r[0] = (INT_MASK&n[0])<<1;
  
  // The generator is filled with the lower 31 bits of the shift register at 
  // each time, shifted up to make room for the bits defining the canonical 
  // form; the node number is XORed into the fill to make the generators unique
  for ( i=1; i<length-1 ; i++ ) 
  {
    advance_reg( temp );
    r[i] = (INT_MASK&(temp[0]^n[i]))<<1;
  }
  r[length-1] = 0;
  
  // The canonical form for the LSB is instituted here 
  k = LFG::valid[param_local].first + LFG::valid[param_local].LSBS;

  for ( j=LFG::valid[param_local].first; j<k; j++ )
    r[j] |= 1;

  return 0;
}

// Update index for next spawning
void si_double( std::vector<unsigned> &a, 
		std::vector<unsigned> &b, 
		int length )
{
  assert( a.size() >= length-1 );
  assert( b.size() >= length-1 );
  
  int i;

  if ( b[length-2]&(1<<MAX_BIT_INT) )
    errprint("WARNING","si_double",TOOMANY);
  
  a[length-2] = (INTX2_MASK&b[length-2])<<1;

  for ( i=length-3; i>=0; i--) 
  {
    if ( b[i]&(1<<MAX_BIT_INT) ) 
      a[i+1]++;
    
    a[i] = (INTX2_MASK&b[i])<<1;
  }
}

// Initialize the streams
LFG** LFG::initialize( GeneratorType rng_type_local, 
		       int ngen_local,
		       int param_local,
		       int seed_local,
		       std::vector<unsigned> &nstart_local,
		       unsigned initseed_local )
{
  assert( nstart_local.size() == LFG::valid[param_local].L-1 );
  
  int i,j,k,l;
  int length = LFG::valid[param_local].L;
  std::vector<int> order( ngen_local ), nindex;
  LFG **q;

  // Allocate memory for the fill of each generator
  q = new LFG *[ngen_local];

  if( q == NULL ) 
    return NULL;

  for( i=0; i<ngen_local; i++ ) 
  {
    q[i] = new LFG;

    if( q[i] == NULL ) 
      return NULL;

    // Initialize generator member data
    q[i]->d_rng_type = d_rng_type_local;
    q[i]->d_hptr = length - 1;
    q[i]->d_si.resize( length-1 );
    q[i]->d_r0.resize( length );
    q[i]->d_r1.resize( length );
    q[i]->d_lval = length;
    q[i]->d_kval = LFG::valid[param_local].K;
    q[i]->d_param = d_param_local;
    q[i]->d_seed = d_seed_local;
    q[i]->d_init_seed = d_initseed_local;
    q[i]->d_gentype = GENTYPE;
  }
  
  // Specify register fills and node number arrays. Do fills in tree fashion 
  // so that all fills branch from index contained in nstart array
  q[0]->d_stream_number = nstart_local[0];
  LFG::si_double(q[0]->d_si,nstart_local,length);
  LFG::get_fill(q[0]->d_si,q[0]->d_r0,param_local,seed_local);
  q[0]->d_si[0]++;
  LFG::get_fill(q[0]->d_si,q[0]->d_r1,param_local,seed_local);

  i = 1;
  order[0] = 0;

  if( ngen_local > 1 ) 
  {
    while( true ) 
    {
      l = i;
      for( k=0; k<l; k++) 
      {
	nindex = q[order[k]]->d_si;
	q[i]->d_stream_number = nindex[0];
	LFG::si_double(nindex,nindex, length);

	for (j=0;j<length-1;j++) 
	  q[i]->d_si[j] = nindex[j];

	LFG::get_fill(q[i]->d_si,q[i]->d_r0,param_local,seed_local);
	q[i]->d_si[0]++;
	LFG::get_fill(q[i]->d_si,q[i]->d_r1,param_local,seed_local);

	if( ngen_local == ++i ) 
	  break;
      }
      
      if( ngen_local == i ) 
	break;
                
      for( k=l-1; k>0; k-- ) 
      {
	order[2*k+1] = l+k;
	order[2*k] = order[k];
      }
      order[1] = l;
    }
  }

  order.clear();

  for( i=ngen_local-1; i>=0; i-- ) 
  {
    k = 0;
    
    for( j=1; j<lv-1; j++ )
      if( q[i]->si[j] ) 
	k = 1;
    if( !k ) 
      break;
    for( j=0; j<length*RUNUP; j++ )
      q[i]->get_rn_int();
  }

  while( i>=0 )
  {
    for( j=0; j<4*length; j++ ) {
      q[i]->get_rn_int(); 
    }

    i--;
  }   

  return q;
}

} // end namespace sprng

//---------------------------------------------------------------------------//
// end LFG.cpp
//---------------------------------------------------------------------------//

