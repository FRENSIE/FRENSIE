#! ${PYTHON_EXECUTABLE}
#-----------------------------------------------------------------------------#
## Utility.Mesh classes unit tests
#  \file   tstUtility.Mesh.py
#  \author Luke Kersting
#  \brief  Unit tests for the Utility.Mesh classes
#-----------------------------------------------------------------------------#

# System imports
import sys
import unittest
from optparse import *
import numpy as np

# Parse the command-line arguments
parser = OptionParser()
parser.add_option("-v", "--verbosity", type="int", dest="verbosity", default=2,
                  help="set the verbosity level [default 2]")
parser.add_option("-f", "--tet_mesh_file", type="string", dest="tet_mesh_file",
                  help="Test Tet file name with path.")
options,args = parser.parse_args()

from testingHelpers import importPyFrensieModuleFromBuildDir
Mesh = importPyFrensieModuleFromBuildDir('Utility.Mesh')

def assertSequenceAlmostEqual( lhs_array, rhs_array, tol ):
  # Test that the array sizes are equal
  if len(lhs_array) != len(rhs_array):
    return False

  # Test that the array entries are almost equal
  for i in range(len(lhs_array)):
    if np.abs(lhs_array[i]) != 0.0:
      if np.abs(lhs_array[i] - rhs_array[i])/np.abs(lhs_array[i]) > tol:
        return False
    else:
      if np.abs(lhs_array[i] - rhs_array[i]) > tol:
        return False

  # If everything passes return True
  return True

#-----------------------------------------------------------------------------#
# Tests.
#-----------------------------------------------------------------------------#
# Test the Translation Cartesian Spatial Mesh Conversion Policy
class TetMeshTestCase(unittest.TestCase):
    "TestCase class for Utility.Mesh.TetMesh class"

    def testConstructor(self):
        "*Test Utility.Mesh.TetMesh constructor"

        mesh = Mesh.TetMesh( options.tet_mesh_file )
        self.assertEqual( mesh.getNumberOfElements(), 6 )

#---------------------------------------------------------------------------#
# Check that the mesh type name can be returned
    def testGetMeshTypeName(self):
        "*Test Utility.Mesh.TetMesh getMeshTypeName"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        self.assertEqual( mesh.getMeshTypeName(), "Tet Mesh" )

#---------------------------------------------------------------------------#
# Check that the mesh element type name can be returned
    def testGetMeshElementTypeName(self):
        "*Test Utility.Mesh.TetMesh getMeshElementTypeName"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        self.assertEqual( mesh.getMeshElementTypeName(), "Tet" )

#---------------------------------------------------------------------------#
# Check that the volume of each tet element can be calculated
    def testGetElementVolumes(self):
        "*Test Utility.Mesh.TetMesh getElementVolumes"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        volume_map = mesh.getElementVolumes()
        self.assertEqual( len(volume_map), 6 )

        for element in volume_map.values():
          self.assertAlmostEqual( element, 1.0/6, delta=1e-15 )

#---------------------------------------------------------------------------#
# Check if a point is in the mesh
    def testIsPointInMesh(self):
        "*Test Utility.Mesh.TetMesh isPointInMesh"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        surface_point_1 = [ 0.25, 0.0, 0.75 ]
        surface_point_2 = [ 0.0, 0.25, 0.75 ]
        surface_point_3 = [ 0.75, 0.0, 0.25 ]
        surface_point_4 = [ 0.0, 0.75, 0.25 ]
        surface_point_5 = [ 0.75, 0.25, 0.0 ]
        surface_point_6 = [ 0.25, 0.75, 0.0 ]
        surface_point_7 = [ 0.75, 0.25, 1.0 ]
        surface_point_8 = [ 0.25, 0.75, 1.0 ]
        surface_point_9 = [ 1.0, 0.25, 0.75 ]
        surface_point_10 = [ 0.25, 1.0, 0.75 ]
        surface_point_11 = [ 1.0, 0.75, 0.25 ]
        surface_point_12 = [ 0.75, 1.0, 0.25 ]
        surface_point_13 = [ 0.0, 0.0, 0.0 ]
        surface_point_14 = [ 1.0, 0.0, 0.0 ]
        surface_point_15 = [ 0.0, 1.0, 0.0 ]
        surface_point_16 = [ 0.0, 0.0, 1.0 ]
        surface_point_17 = [ 0.0, 1.0, 1.0 ]
        surface_point_18 = [ 1.0, 0.0, 1.0 ]
        surface_point_19 = [ 1.0, 1.0, 0.0 ]
        surface_point_20 = [ 1.0, 1.0, 1.0 ]
        self.assertTrue( mesh.isPointInMesh( surface_point_1 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_2 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_3 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_4 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_5 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_6 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_7 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_8 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_9 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_10 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_11 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_12 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_13 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_14 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_15 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_16 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_17 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_18 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_19 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_20 ) )

        outside_point_1 = [ 0.5, 0.5, -0.5 ]
        outside_point_2 = [ 0.5, 0.5, 1.5 ]
        outside_point_3 = [ 0.5, -0.5, 0.5 ]
        outside_point_4 = [ 0.5, 1.5, 0.5 ]
        outside_point_5 = [ -0.5, 0.5, 0.5 ]
        outside_point_6 = [ 1.5, 0.5, 0.5 ]
        self.assertFalse( mesh.isPointInMesh( outside_point_1 ) )
        self.assertFalse( mesh.isPointInMesh( outside_point_2 ) )
        self.assertFalse( mesh.isPointInMesh( outside_point_3 ) )
        self.assertFalse( mesh.isPointInMesh( outside_point_4 ) )
        self.assertFalse( mesh.isPointInMesh( outside_point_5 ) )
        self.assertFalse( mesh.isPointInMesh( outside_point_6 ) )

        inside_point_1 = [ 0.5, 0.5, 0.5 ]
        inside_point_2 = [ 0.0, 0.0, 0.5 ]
        inside_point_3 = [ 0.0, 0.5, 0.0 ]
        inside_point_4 = [ 0.5, 0.0, 0.0 ]
        inside_point_5 = [ 0.0, 0.5, 0.5 ]
        inside_point_6 = [ 0.5, 0.0, 0.5 ]
        inside_point_7 = [ 0.5, 0.5, 0.0 ]
        self.assertTrue( mesh.isPointInMesh( surface_point_1 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_2 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_3 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_4 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_5 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_6 ) )
        self.assertTrue( mesh.isPointInMesh( surface_point_7 ) )

#---------------------------------------------------------------------------#
# Check that the tet that a point falls in can be determined
    def testWhichElementIsPointIn(self):
        "*Test Utility.Mesh.TetMesh whichElementIsPointIn"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        inside_point_1 = [ 0.5, 0.25, 0.75 ]
        inside_point_2 = [ 0.75, 0.25, 0.5 ]
        inside_point_3 = [ 0.25, 0.5, 0.75 ]
        inside_point_4 = [ 0.25, 0.75, 0.5 ]
        inside_point_5 = [ 0.75, 0.75, 0.25 ]
        inside_point_6 = [ 0.5, 0.75, 0.25 ]
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_1 ),
                       5764607523034234881 )
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_2 ),
                       5764607523034234882 )
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_3 ),
                       5764607523034234883 )
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_4 ),
                       5764607523034234884 )
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_5 ),
                       5764607523034234885 )
        self.assertEqual( mesh.whichElementIsPointIn( inside_point_6 ),
                       5764607523034234886 )

        surface_point_1 = [ 0.25, 0.0, 0.75 ]
        surface_point_2 = [ 0.0, 0.25, 0.75 ]
        surface_point_3 = [ 0.75, 0.0, 0.25 ]
        surface_point_4 = [ 0.0, 0.75, 0.25 ]
        surface_point_5 = [ 0.75, 0.25, 0.0 ]
        surface_point_6 = [ 0.25, 0.75, 0.0 ]
        surface_point_7 = [ 0.75, 0.25, 1.0 ]
        surface_point_8 = [ 0.25, 0.75, 1.0 ]
        surface_point_9 = [ 1.0, 0.25, 0.75 ]
        surface_point_10 = [ 0.25, 1.0, 0.75 ]
        surface_point_11 = [ 1.0, 0.75, 0.25 ]
        surface_point_12 = [ 0.75, 1.0, 0.25 ]
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_1 ),
                       5764607523034234881 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_2 ),
                       5764607523034234883 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_3 ),
                       5764607523034234882 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_4 ),
                       5764607523034234884 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_5 ),
                       5764607523034234885 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_6 ),
                       5764607523034234886 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_7 ),
                       5764607523034234881 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_8 ),
                       5764607523034234883 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_9 ),
                       5764607523034234882 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_10 ),
                       5764607523034234884 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_11 ),
                       5764607523034234885 )
        self.assertEqual( mesh.whichElementIsPointIn( surface_point_12 ),
                       5764607523034234886 )

#---------------------------------------------------------------------------#
# Check that the tracks through tets can be calculated
    def testComputeTrackLengths(self):
        "*Test Utility.Mesh.TetMesh computeTrackLengths"
        mesh = Mesh.TetMesh( options.tet_mesh_file )

        start_point = [None]*3
        end_point = [None]*3

        # No intersection
        start_point[0] = 2.0
        start_point[1] = -1.0
        start_point[2] = 0.0

        end_point[0] = 4.0
        end_point[1] = -1.0
        end_point[2] = 0.0

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertTrue( len(contribution) == 0 )

        # Start and end point on mesh element surfaces
        start_point[0] = 0.25
        start_point[1] = 0.0
        start_point[2] = 0.75

        end_point[0] = 0.75
        end_point[1] = 0.25
        end_point[2] = 1.0

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234881 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.25, 0.0, 0.75 ] )
        self.assertAlmostEqual( contribution[0][2], 0.6123724356957945, delta=1e-12 )

        # Start point outside of mesh, end point on mesh element surface
        # start intersection { 0.0, 0.25, 0.75 }
        start_point[0] = -0.4082482904638631
        start_point[1] = -0.5664965809277261
        start_point[2] = 0.3417517095361369

        end_point[0] = 0.25
        end_point[1] = 0.75
        end_point[2] = 1.0

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234883 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.0, 0.25, 0.75 ] )
        self.assertAlmostEqual( contribution[0][2], 0.6123724356957945, delta=1e-12 )

        # Start point on mesh element surface, end point outside of surface
        # end intersection { 1.0, 0.25, 0.75 }
        start_point[0] = 0.75
        start_point[1] = 0.0
        start_point[2] = 0.25

        end_point[0] = 1.4082482904638631
        end_point[1] = 0.6582482904638631
        end_point[2] = 1.5664965809277263

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234882 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.75, 0.0, 0.25 ] )
        self.assertAlmostEqual( contribution[0][2], 0.6123724356957945, delta=1e-12 )

        # Start point and end point outside of surface
        # start intersection { 0.0, 0.75, 0.25 }
        # end intersection { 0.25, 1.0, 0.75 }
        start_point[0] = -0.4082482904638631
        start_point[1] = 0.3417517095361369
        start_point[2] = -0.5664965809277261

        end_point[0] = 0.6582482904638631
        end_point[1] = 1.4082482904638631
        end_point[2] = 1.5664965809277263

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234884 )
        self.assertTrue( contribution[0][1][0] < 1e-12 )
        self.assertAlmostEqual( contribution[0][1][1], 0.75, delta=1e-12 )
        self.assertAlmostEqual( contribution[0][1][2], 0.25, delta=1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.6123724356957945, delta=1e-12 )

        # Start point outside of mesh, end point inside of mesh element
        # start intersection { 0.75, 0.25, 0.0 }
        start_point[0] = 0.3417517095361369
        start_point[1] = -0.5664965809277261
        start_point[2] = -0.4082482904638631

        end_point[0] = 0.875
        end_point[1] = 0.5
        end_point[2] = 0.125

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234885 )
        self.assertAlmostEqual( contribution[0][1][0], 0.75, delta=1e-12 )
        self.assertAlmostEqual( contribution[0][1][1], 0.25, delta=1e-12 )
        self.assertTrue( contribution[0][1][2] < 1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.30618621784789724, delta=1e-12 )

        # Start point inside of mesh, end point outside of mesh
        # end intersection { 1.0, 0.75, 0.25 }
        start_point[0] = 0.875
        start_point[1] = 0.5
        start_point[2] = 0.125

        end_point[0] = 1.4082482904638631
        end_point[1] = 1.5664965809277263
        end_point[2] = 0.6582482904638631

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234885 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.875, 0.5, 0.125 ] )
        self.assertAlmostEqual( contribution[0][2], 0.30618621784789724, delta=1e-12 )

        # Start point on mesh element surface, end point in mesh element
        # start intersection { 0.25, 0.75, 0.0 }
        start_point[0] = 0.25
        start_point[1] = 0.75
        start_point[2] = 0.0

        end_point[0] = 0.41666666666666663
        end_point[1] = 0.8333333333333334
        end_point[2] = 0.08333333333333333

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234886 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.25, 0.75, 0.0 ] )
        self.assertAlmostEqual( contribution[0][2], 0.20412414523193148, delta=1e-12 )

        # Start point in mesh element, end point in mesh element
        start_point[0] = 0.41666666666666663
        start_point[1] = 0.8333333333333334
        start_point[2] = 0.08333333333333333

        end_point[0] = 0.5833333333333333
        end_point[1] = 0.9166666666666666
        end_point[2] = 0.16666666666666666

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234886 )
        assertSequenceAlmostEqual( contribution[0][1],
                                [0.41666666666666663, 0.8333333333333334, 0.08333333333333333],
                                1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.20412414523193148, delta=1e-12 )

        # Start point in mesh element, end point on mesh element surface
        # end intersection { 0.75, 1.0, 0.25 }
        start_point[0] = 0.5833333333333333
        start_point[1] = 0.9166666666666666
        start_point[2] = 0.16666666666666666

        end_point[0] = 0.75
        end_point[1] = 1.0
        end_point[2] = 0.25

        contribution = mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 5764607523034234886 )
        assertSequenceAlmostEqual( contribution[0][1], [0.5833333333333333, 0.9166666666666666, 0.16666666666666666], 1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.20412414523193148, delta=1e-12 )


#-----------------------------------------------------------------------------#
# Test the StructuredHexMesh
class StructuredHexMeshTestCase(unittest.TestCase):
    "TestCase class for Utility.Mesh.StructuredHexMesh class"

    def testConstructor(self):
        "*Test Utility.Mesh.StructuredHexMesh constructor"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        self.assertEqual( len(x_planes), hex_mesh.getNumberOfXPlanes() )

        for i in range(len(x_planes)):
          self.assertAlmostEqual( hex_mesh.getXPlaneLocation(i), x_planes[i], delta=1e-12 )

        self.assertEqual( len(y_planes), hex_mesh.getNumberOfYPlanes() )

        for i in range(len(y_planes)):
          self.assertAlmostEqual( hex_mesh.getYPlaneLocation(i), y_planes[i], delta=1e-12 )

        self.assertEqual( len(z_planes), hex_mesh.getNumberOfZPlanes() )

        for i in range(len(z_planes)):
          self.assertAlmostEqual( hex_mesh.getZPlaneLocation(i), z_planes[i], delta=1e-12 )

        self.assertEqual( hex_mesh.getNumberOfElements(), (len(z_planes)-1)*(len(y_planes)-1)*(len(x_planes)-1) )

        handles = hex_mesh.getElementHandles()
        self.assertEqual( (len(z_planes)-1)*(len(y_planes)-1)*(len(x_planes)-1), len(handles) )


#---------------------------------------------------------------------------#
# Test the getMeshTypeName method
    def testGetMeshTypeName(self):
        "*Test Utility.Mesh.StructuredHexMesh getMeshTypeName"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        self.assertEqual( hex_mesh.getMeshTypeName(),
                       "Structured Hex Mesh" )

#---------------------------------------------------------------------------#
# Test the getMeshElementTypeName method
    def testGetMeshElementTypeName(self):
        "*Test Utility.Mesh.StructuredHexMesh getMeshElementTypeName"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        self.assertEqual( hex_mesh.getMeshElementTypeName(), "Hex" )

#---------------------------------------------------------------------------#
# Test the getElementVolumes method
    def testGetElementVolumes(self):
        "*Test Utility.Mesh.StructuredHexMesh getElementVolumes"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        volume_map = hex_mesh.getElementVolumes()

        self.assertEqual( len(volume_map), 8 )
        self.assertAlmostEqual( volume_map[0], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[1], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[2], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[3], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[4], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[5], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[6], 0.125, delta=1e-12)
        self.assertAlmostEqual( volume_map[7], 0.125, delta=1e-12)

#---------------------------------------------------------------------------#
# test whether or not the point in mesh method works
    def testIsPointInMesh(self):
        "*Test Utility.Mesh.StructuredHexMesh isPointInMesh"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )
        # Points inside mesh and not in boundary region
        point1 = [ 0.5, 0.5, 0.5 ]
        point2 = [ 0.25, 0.25, 0.25 ]
        point3 = [ 0.75, 0.75, 0.75 ]
        point4 = [ 0.25, 0.9, 0.23 ]
        self.assertTrue( hex_mesh.isPointInMesh(point1) )
        self.assertTrue( hex_mesh.isPointInMesh(point2) )
        self.assertTrue( hex_mesh.isPointInMesh(point3) )
        self.assertTrue( hex_mesh.isPointInMesh(point4) )
        # Points not inside mesh but inside boundary region (should return false)
        # Points on upper dimension boundaries
        point5 = [ 1.0 + 1e-13, 0.5, 0.5 ]
        point6 = [ 0.5, 1.0 + 1e-13, 0.5 ]
        point7 = [ 0.5, 0.5, 1.0 + 1e-13 ]
        #points on lower dimension boundaries
        point8 = [ -1e-13, 0.5, 0.5 ]
        point9 = [ 0.5, -1e-13, 0.5 ]
        point10 = [ 0.5, 0.5, -1e-13 ]
        self.assertFalse( hex_mesh.isPointInMesh(point5) )
        self.assertFalse( hex_mesh.isPointInMesh(point6) )
        self.assertFalse( hex_mesh.isPointInMesh(point7) )
        self.assertFalse( hex_mesh.isPointInMesh(point8) )
        self.assertFalse( hex_mesh.isPointInMesh(point9) )
        self.assertFalse( hex_mesh.isPointInMesh(point10) )
        # Points outside of mesh
        # Points on upper dimension boundaries
        point11 = [ 1.0 + 1e-5, 0.5, 0.5 ]
        point12 = [ 0.5, 1.0 + 1e-5, 0.5 ]
        point13 = [ 0.5, 0.5, 1.0 + 1e-5 ]
        #points on lower dimension boundaries
        point14 = [ -1e-5, 0.5, 0.5 ]
        point15 = [ 0.5, -1e-5, 0.5 ]
        point16 = [ 0.5, 0.5, -1e-5 ]
        self.assertFalse( hex_mesh.isPointInMesh(point11) )
        self.assertFalse( hex_mesh.isPointInMesh(point12) )
        self.assertFalse( hex_mesh.isPointInMesh(point13) )
        self.assertFalse( hex_mesh.isPointInMesh(point14) )
        self.assertFalse( hex_mesh.isPointInMesh(point15) )
        self.assertFalse( hex_mesh.isPointInMesh(point16) )

#---------------------------------------------------------------------------#
# test whether or not the whichHexIsPointIn method works
    def testWhichElementIsPointIn(self):
        "*Test Utility.Mesh.StructuredHexMesh whichElementIsPointIn"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )
        # Test points in the middle of the mesh elements. Points should be in order for index returned
        point1 = [ 0.25, 0.25, 0.25 ]
        point2 = [ 0.75, 0.25, 0.25 ]
        point3 = [ 0.25, 0.75, 0.25 ]
        point4 = [ 0.75, 0.75, 0.25 ]
        point5 = [ 0.25, 0.25, 0.75 ]
        point6 = [ 0.75, 0.25, 0.75 ]
        point7 = [ 0.25, 0.75, 0.75 ]
        point8 = [ 0.75, 0.75, 0.75 ]
        self.assertEqual( hex_mesh.whichElementIsPointIn(point1), 0)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point2), 1)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point3), 2)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point4), 3)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point5), 4)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point6), 5)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point7), 6)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point8), 7)

        # test points on mesh boundaries.
        point9 = [ 0.0, 0.0, 0.0 ]
        point10 = [ 0.5, 0.5, 0.5 ]
        point11 = [ 1.0, 1.0, 1.0 ]
        self.assertEqual( hex_mesh.whichElementIsPointIn(point9), 0)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point10), 7)
        self.assertEqual( hex_mesh.whichElementIsPointIn(point11), 7)

#---------------------------------------------------------------------------#
# test simple cases of rays not interacting with mesh and computeTrackLengths
# returning empty arrays
    def testComputeTrackLengths_no_intersection(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_no_intersection"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3
        # Test a point heading away from the mesh and not intersecting with anything

        start_point[0] = 1.1
        start_point[1] = 1.1
        start_point[2] = 1.1

        end_point[0] = 2.0
        end_point[1] = 2.0
        end_point[2] = 2.0

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertTrue( len(contribution) == 0 )

        #reverse order of last example making particle travel towards mesh but never enter it due to short length
        start_point[0] = 2.0
        start_point[1] = 2.0
        start_point[2] = 2.0

        end_point[0] = 1.1
        end_point[1] = 1.1
        end_point[2] = 1.1

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )
        # Particle crosses planes but still never actually crosses mesh
        start_point[0] = 2.0
        start_point[1] = 2.0
        start_point[2] = 2.0

        end_point[0] = 1.0
        end_point[1] = 2.0
        end_point[2] = 2.0

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertTrue( len(contribution) == 0 )
        # Particle ends in boundary region. Should give zero since pushing it up to
        # The actual boundary would be longer than the particle track length
        start_point[0] = 2.0
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 1.0+1e-7
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertTrue( len(contribution) == 0 )

#---------------------------------------------------------------------------#
# testing cases of rays interacting with mesh and returning appropriate
# results (particle track is entirely within one cell)
    def testComputeTrackLengths_one_cell(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_one_cell"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        # should also note that because all direction components are positive, this
        # also tests whether or not the function appropriately finds different
        # interaction planes and hex index planes
        start_point[0] = 0.1
        start_point[1] = 0.1
        start_point[2] = 0.1

        end_point[0] = 0.4
        end_point[1] = 0.25
        end_point[2] = 0.15

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 0 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.1, 0.1, 0.1 ] )
        self.assertAlmostEqual( contribution[0][2], 0.339116499156263, delta=1e-10 )

#---------------------------------------------------------------------------#
# testing cases of rays interacting with mesh and returning appropriate
# results (particle starts in mesh and crosses into another mesh element and
# dies in that mesh element)
    def testComputeTrackLengths_multiple_elements(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_multiple_elements"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = 0.1
        start_point[1] = 0.1
        start_point[2] = 0.1

        end_point[0] = 0.6
        end_point[1] = 0.25
        end_point[2] = 0.15

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 2)
        self.assertEqual( contribution[0][0], 0)
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.1, 0.1, 0.1 ] )
        self.assertAlmostEqual( contribution[0][2], 0.419523539268061, delta=1e-10 )
        self.assertEqual( contribution[1][0], 1)
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 0.5, 0.22, 0.14],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.104880884817015, delta=1e-10 )

  #one extra check with different plane dimension crossing to make sure any of the planes work
        start_point[0] = 0.7
        start_point[1] = 0.6
        start_point[2] = 0.8

        end_point[0] = 0.76
        end_point[1] = 0.55
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 2 )
        self.assertEqual( contribution[0][0], 7 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.7, 0.6, 0.8 ] )
        self.assertAlmostEqual( contribution[0][2], 0.303009696269043, delta=1e-10 )
        self.assertEqual( contribution[1][0], 3 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 7.327272727272726716e-01, 5.727272727272727515e-01, 0.5],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.252508080224203, delta=1e-10 )
        # Test multiple plane crossings
        start_point[0] = 0.7
        start_point[1] = 0.6
        start_point[2] = 0.8

        end_point[0] = 0.36
        end_point[1] = 0.2
        end_point[2] = 0.81

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 3 )
        self.assertEqual( contribution[0][0], 7 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.7, 0.6, 0.8 ] )
        self.assertAlmostEqual( contribution[0][2], 0.131267855928251, delta=1e-10 )
        self.assertEqual( contribution[1][0], 5 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 6.149999999999999911e-01, 0.5, 8.024999999999999911e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.177597687432339, delta=1e-10 )
        self.assertEqual( contribution[2][0], 4 )
        assertSequenceAlmostEqual( contribution[2][1],
                                [ 0.5, 3.647058823529412130e-01, 8.058823529411764941e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[2][2], 0.216205880352413, delta=1e-10 )

        sum_of_segments = contribution[0][2] + contribution[1][2] + contribution[2][2]

        self.assertAlmostEqual( sum_of_segments, ray_length, delta=1e-10 )

#---------------------------------------------------------------------------#
# testing cases of rays interacting with mesh and returning appropriate
# results (particle starts in mesh and exits mesh)
    def testComputeTrackLengths_starts_mesh_exits_mesh(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_starts_mesh_exits_mesh"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3
        # Particle starts in first cell and exits in the negative direction
        start_point[0] = 0.25
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = -0.25
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 0 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.25, 0.25, 0.25 ] )
        self.assertEqual( contribution[0][2], 0.25 )
        # Particle starts in another cell and crosses multiple planes before exiting
        start_point[0] = 0.268
        start_point[1] = 0.138
        start_point[2] = 0.922

        end_point[0] = 1.3
        end_point[1] = 0.9
        end_point[2] = -1.2

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 3 )
        self.assertEqual( contribution[0][0], 4 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.268, 0.138, 0.922 ] )
        self.assertAlmostEqual( contribution[0][2], 0.493120998659465, delta=1e-10 )
        self.assertEqual( contribution[1][0], 0 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 4.732327992459943733e-01, 2.895381715362865815e-01, 0.5],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.064314616453253, delta=1e-10 )
        self.assertEqual( contribution[2][0], 1 )
        assertSequenceAlmostEqual( contribution[2][1],
                                [ 0.5, 3.093023255813953654e-01, 4.449612403100776103e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[2][2], 0.519951969636160, delta=1e-10 )

#---------------------------------------------------------------------------#
# testing cases of where the particle starts outside of the mesh and enters
# the mesh (simple cases of particle entering mesh)
    def testComputeTrackLengths_enters_mesh(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_enters_mesh"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3
        # Particle starts outside mesh and enters first cell
        start_point[0] = -0.25
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 0.25
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 0 )
        self.assertSequenceEqual( list(contribution[0][1]), [ 0.0, 0.25, 0.25 ] )
        self.assertAlmostEqual( contribution[0][2], 0.25, delta=1e-12 )
        # Particle starts outside mesh,crosses multiple planes inside mesh, and
        # dies inside mesh
        start_point[0] = -0.25
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 0.83
        end_point[1] = 0.73
        end_point[2] = 0.52

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 4 )
        self.assertEqual( contribution[0][0], 0 )
        assertSequenceAlmostEqual( contribution[0][1],
                                [ 0.0, 3.611111111111111049e-01, 0.3125],
                                1e-10 )
        self.assertAlmostEqual( contribution[0][2], 0.350784676235707, delta=1e-10 )

        self.assertEqual( contribution[1][0], 2 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 0.3125, 0.5, 3.906250000000000000e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.210470805741424, delta=1e-10 )

        self.assertEqual( contribution[2][0], 3 )
        assertSequenceAlmostEqual( contribution[2][1],
                                [ 0.5, 5.833333333333333703e-01, 4.375000000000000000e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[2][2], 0.280627740988566, delta=1e-10 )

        self.assertEqual( contribution[3][0], 7 )
        assertSequenceAlmostEqual( contribution[3][1],
                                [ 0.75, 6.944444444444444198e-01, 0.5],
                                1e-10 )
        self.assertAlmostEqual( contribution[3][2], 0.089800877116341, delta=1e-10 )
        # Particle starts outside mesh, and returns interaction planes that are
        # outside mesh before actual interaction plane
        start_point[0] = -0.25
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 0.01
        end_point[1] = 0.99
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 1 )
        self.assertEqual( contribution[0][0], 2 )
        assertSequenceAlmostEqual( contribution[0][1],
                                [ 0.0, 9.615384615384614531e-01, 2.500000000000000000e-01],
                                1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.030167187001735, delta=1e-12)
        # Particle starts outside mesh, enters mesh, and then exits mesh
        start_point[0] = 1.2
        start_point[1] = 1.3
        start_point[2] = 1.1

        end_point[0] = -0.2
        end_point[1] = -3
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 2 )
        self.assertEqual( contribution[0][0], 7 )
        assertSequenceAlmostEqual( contribution[0][1],
                                [ 1.0, 6.857142857142859427e-01, 9.785714285714286476e-01],
                                1e-12 )
        self.assertAlmostEqual( contribution[0][2], 0.198729768889349, delta=1e-12 )
        self.assertEqual( contribution[1][0], 5 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 9.395348837209301918e-01, 0.5, 9.418604651162790775e-01],
                                1e-12 )
        self.assertAlmostEqual( contribution[1][2], 0.535041685471324, delta=1e-12 )

#---------------------------------------------------------------------------#
# bounding region cases (particle starts in boundary region and travels away
# from mesh on negative side)
    def testComputeTrackLengths_boundary_region_special_case_negative_away_from_mesh(self):
        "*Test Utility.Mesh.StructuredHexMesh constructor"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = -1e-13
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = -0.25
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )

#---------------------------------------------------------------------------#
# bounding region cases (particle starts in boundary region and travels away
# from mesh on positive side)
    def testComputeTrackLengths_boundary_region_special_case_positive_away_from_mesh(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_boundary_region_special_case_positive_away_from_mesh"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = 1+1e-13
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 2
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )

#---------------------------------------------------------------------------#
# bounding region cases (particle starts in boundary region and dies in
# boundary region)
    def testComputeTrackLengths_boundary_region_special_case_stays_in_region(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_boundary_region_special_case_stays_in_region"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = 1+1e-13
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 1+1e-13
        end_point[1] = 0.75
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )
        # Particle starts in boundary region and dies in boundary region going
        # Towards boundary region
        start_point[0] = 1+1e-13
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 1+1e-14
        end_point[1] = 0.75
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )

        # same as last but on other side for y dimension
        start_point[0] = 0.25
        start_point[1] = -1e-13
        start_point[2] = 0.25

        end_point[0] = 0.75
        end_point[1] = -5e-10
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )
        # Test particle starting in boundary region and stopping at hex face
        start_point[0] = 0.25
        start_point[1] = -1e-13
        start_point[2] = 0.25

        end_point[0] = 0.75
        end_point[1] = 0
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 0 )

#---------------------------------------------------------------------------#
# bounding region cases (particle starts in boundary region and dies inside
# mesh)
    def testComputeTrackLengths_boundary_region_special_case_enters_mesh(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_boundary_region_special_case_enters_mesh"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = 1+5e-13
        start_point[1] = 0.25
        start_point[2] = 0.25

        end_point[0] = 0.5
        end_point[1] = 0.75
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 2 )
        self.assertEqual( contribution[0][0], 1 )
        assertSequenceAlmostEqual( list(contribution[0][1]), [ 1.0, 0.25, 0.25], 1e-10 )
        self.assertAlmostEqual( contribution[0][2], 0.353553390592743, delta=1e-10 )
        self.assertEqual( contribution[1][0], 3 )
        assertSequenceAlmostEqual( list(contribution[1][1]), [ 0.75, 0.5, 0.25], 1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.353553390593451, delta=1e-10 )

#---------------------------------------------------------------------------#
# Test the ability for the function computeTrackLengths to find the correct
# entry point that a particle enters a mesh at. Specifically test the other
# dimensions under specific conditions where multiple intersection points are
# inside mesh but a dimension after the first one in order of x,y,z is the
# true intersection point
    def testComputeTrackLengths_enters_correct_dimension(self):
        "*Test Utility.Mesh.StructuredHexMesh computeTrackLengths_enters_correct_dimension"
        x_planes = [ 0.0, 0.5, 1.0 ]
        y_planes = [ 0.0, 0.5, 1.0 ]
        z_planes = [ 0.0, 0.5, 1.0 ]

        hex_mesh = Mesh.StructuredHexMesh( x_planes, y_planes, z_planes )

        start_point = [None]*3
        end_point = [None]*3
        ray = [None]*3
        direction = [None]*3

        start_point[0] = 0.25
        start_point[1] = 0.25
        start_point[2] = -1e-9

        end_point[0] = 0.6
        end_point[1] = 0.25
        end_point[2] = 0.25

        ray[0] = end_point[0] - start_point[0]
        ray[1] = end_point[1] - start_point[1]
        ray[2] = end_point[2] - start_point[2]

        ray_length = np.sqrt(ray[0]**2+ray[1]**2+ray[2]**2)

        direction[0] = ray[0] / ray_length
        direction[1] = ray[1] / ray_length
        direction[2] = ray[2] / ray_length

        contribution = hex_mesh.computeTrackLengths( start_point, end_point )

        self.assertEqual( len(contribution), 2 )

        self.assertEqual( contribution[0][0], 0 )
        assertSequenceAlmostEqual( list(contribution[0][1]),
                                [ 0.25, 0.25, 0.0],
                                1e-8 )
        self.assertAlmostEqual( contribution[0][2], 0.307225901089085, delta=1e-10 )
        self.assertEqual( contribution[1][0], 1 )
        assertSequenceAlmostEqual( list(contribution[1][1]),
                                [ 0.5, 0.25, 1.785714282857143176e-01],
                                1e-10 )
        self.assertAlmostEqual( contribution[1][2], 0.122890361123820, delta=1e-10 )

        self.assertAlmostEqual( ray_length - 1.720465048851618e-09, contribution[0][2] + contribution[1][2], delta=1e-10)

#-----------------------------------------------------------------------------#
# Custom main
#-----------------------------------------------------------------------------#
if __name__ == "__main__":

    # Create the test suite object
    suite = unittest.TestSuite()

    # Add the test cases to the test suite
    suite.addTest(unittest.makeSuite(TetMeshTestCase))
    suite.addTest(unittest.makeSuite(StructuredHexMeshTestCase))


    print >>sys.stderr, \
        "\n****************************\n" + \
        "Testing Utility.Mesh \n" + \
        "****************************\n"
    result = unittest.TextTestRunner(verbosity=options.verbosity).run(suite)

    errs_plus_fails = len(result.errors) + len(result.failures)

    if errs_plus_fails == 0:
        print "End Result: TEST PASSED"

    # Delete the suite
    del suite

    # Exit
    sys.exit(errs_plus_fails)

#-----------------------------------------------------------------------------#
# end tstUtility.Mesh.py
#-----------------------------------------------------------------------------#
